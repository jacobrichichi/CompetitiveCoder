{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _class, _temp;\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport Panel from './Panel';\nimport Divider from './Divider';\nexport { Divider, Panel };\nvar PanelGroup = (_temp = _class = function (_React$Component) {\n  _inherits(PanelGroup, _React$Component); // Load initial panel configuration from props\n\n\n  function PanelGroup() {\n    _classCallCheck(this, PanelGroup);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var _this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args)));\n\n    _this.defaultResize = function (props, index, defaultResize) {\n      var resize = defaultResize;\n\n      if (props.panelWidths[index].resize) {\n        resize = props.panelWidths[index].resize; // eslint-disable-line\n      } else {\n        resize = props.panelWidths[index].size ? 'dynamic' : resize;\n      }\n\n      return resize;\n    };\n\n    _this.loadPanels = function (props) {\n      var panels = [];\n\n      if (props.children) {\n        // Default values if none were provided\n        var defaultSize = 256;\n        var defaultMinSize = 48;\n        var defaultMaxSize = 0;\n        var defaultResize = 'stretch';\n        var stretchIncluded = false;\n        var children = React.Children.toArray(props.children);\n\n        for (var i = 0; i < children.length; i++) {\n          if (i < props.panelWidths.length && props.panelWidths[i]) {\n            var widthObj = {\n              size: props.panelWidths[i].size !== undefined ? props.panelWidths[i].size : defaultSize,\n              minSize: props.panelWidths[i].minSize !== undefined ? props.panelWidths[i].minSize : defaultMinSize,\n              maxSize: props.panelWidths[i].maxSize !== undefined ? props.panelWidths[i].maxSize : defaultMaxSize,\n              resize: _this.defaultResize(props, i, defaultResize),\n              snap: props.panelWidths[i].snap !== undefined ? props.panelWidths[i].snap : [],\n              style: _extends({}, _this.getPanelClass().defaultProps.style, props.panelWidths[i].style || {})\n            };\n            panels.push(widthObj);\n          } else {\n            // default values if no props are given\n            panels.push({\n              size: defaultSize,\n              resize: defaultResize,\n              minSize: defaultMinSize,\n              maxSize: defaultMaxSize,\n              snap: [],\n              style: {}\n            });\n          } // if none of the panels included was stretchy, make the last one stretchy\n\n\n          if (panels[i].resize === 'stretch') stretchIncluded = true;\n          if (!stretchIncluded && i === children.length - 1) panels[i].resize = 'stretch';\n        }\n      }\n\n      return {\n        panels: panels\n      };\n    };\n\n    _this.onUpdate = function (panels) {\n      if (_this.props.onUpdate) {\n        _this.props.onUpdate(panels.slice());\n      }\n    };\n\n    _this.onResizeStart = function () {\n      if (_this.props.onResizeStart) {\n        // actually this slice clones only array, underlying objects stays the same\n        _this.props.onResizeStart(_this.state.panels.slice());\n      }\n    };\n\n    _this.onResizeEnd = function () {\n      if (_this.props.onResizeEnd) {\n        _this.props.onResizeEnd(_this.state.panels.slice());\n      }\n    };\n\n    _this.getSizeDirection = function (caps) {\n      if (caps) {\n        return _this.props.direction === 'column' ? 'Height' : 'Width';\n      }\n\n      return _this.props.direction === 'column' ? 'height' : 'width';\n    };\n\n    _this.handleResize = function (i, delta) {\n      var tempPanels = _this.state.panels.slice();\n\n      var returnDelta = _this.resizePanel(i, _this.props.direction === 'row' ? delta.x : delta.y, tempPanels);\n\n      _this.setState({\n        panels: tempPanels\n      });\n\n      _this.onUpdate(tempPanels);\n\n      return returnDelta;\n    };\n\n    _this.resizePanel = function (panelIndex, delta, panels) {\n      // 1) first let's calculate and make sure all the sizes add up to be correct.\n      var masterSize = 0;\n\n      for (var iti = 0; iti < panels.length; iti += 1) {\n        masterSize += panels[iti].size;\n      }\n\n      var boundingRect = _this.node.getBoundingClientRect();\n\n      var boundingSize = (_this.props.direction === 'column' ? boundingRect.height : boundingRect.width) - _this.props.spacing * (_this.props.children.length - 1);\n\n      if (Math.abs(boundingSize - masterSize) <= 0.01) {\n        // Debug log\n        // console.log({ panels }, `ERROR! SIZES DON'T MATCH!: ${masterSize}, ${boundingSize}`)\n        // 2) Rectify the situation by adding all the unacounted for space to the first panel\n        panels[panelIndex].size += boundingSize - masterSize;\n      }\n\n      var minsize = void 0;\n      var maxsize = void 0; // track the progressive delta so we can report back how much this panel\n      // actually moved after all the adjustments have been made\n\n      var resultDelta = delta; // make the changes and deal with the consequences later\n\n      panels[panelIndex].size += delta;\n      panels[panelIndex + 1].size -= delta; // Min and max for LEFT panel\n\n      minsize = _this.getPanelMinSize(panelIndex, panels);\n      maxsize = _this.getPanelMaxSize(panelIndex, panels); // if we made the left panel too small\n\n      if (panels[panelIndex].size < minsize) {\n        delta = minsize - panels[panelIndex].size;\n\n        if (panelIndex === 0) {\n          resultDelta = _this.resizePanel(panelIndex, delta, panels);\n        } else {\n          resultDelta = _this.resizePanel(panelIndex - 1, -delta, panels);\n        }\n      } // if we made the left panel too big\n\n\n      if (maxsize !== 0 && panels[panelIndex].size > maxsize) {\n        delta = panels[panelIndex].size - maxsize;\n\n        if (panelIndex === 0) {\n          resultDelta = _this.resizePanel(panelIndex, -delta, panels);\n        } else {\n          resultDelta = _this.resizePanel(panelIndex - 1, delta, panels);\n        }\n      } // Min and max for RIGHT panel\n\n\n      minsize = _this.getPanelMinSize(panelIndex + 1, panels);\n      maxsize = _this.getPanelMaxSize(panelIndex + 1, panels); // if we made the right panel too small\n\n      if (panels[panelIndex + 1].size < minsize) {\n        delta = minsize - panels[panelIndex + 1].size;\n\n        if (panelIndex + 1 === panels.length - 1) {\n          resultDelta = _this.resizePanel(panelIndex, -delta, panels);\n        } else {\n          resultDelta = _this.resizePanel(panelIndex + 1, delta, panels);\n        }\n      } // if we made the right panel too big\n\n\n      if (maxsize !== 0 && panels[panelIndex + 1].size > maxsize) {\n        delta = panels[panelIndex + 1].size - maxsize;\n\n        if (panelIndex + 1 === panels.length - 1) {\n          resultDelta = _this.resizePanel(panelIndex, delta, panels);\n        } else {\n          resultDelta = _this.resizePanel(panelIndex + 1, -delta, panels);\n        }\n      } // Iterate through left panel's snap positions\n\n\n      for (var i = 0; i < panels[panelIndex].snap.length; i++) {\n        if (Math.abs(panels[panelIndex].snap[i] - panels[panelIndex].size) < 20) {\n          delta = panels[panelIndex].snap[i] - panels[panelIndex].size;\n\n          if (delta !== 0 && panels[panelIndex].size + delta >= _this.getPanelMinSize(panelIndex, panels) && panels[panelIndex + 1].size - delta >= _this.getPanelMinSize(panelIndex + 1, panels)) {\n            resultDelta = _this.resizePanel(panelIndex, delta, panels);\n          }\n        }\n      } // Iterate through right panel's snap positions\n\n\n      for (var _i = 0; _i < panels[panelIndex + 1].snap.length; _i++) {\n        if (Math.abs(panels[panelIndex + 1].snap[_i] - panels[panelIndex + 1].size) < 20) {\n          delta = panels[panelIndex + 1].snap[_i] - panels[panelIndex + 1].size;\n\n          if (delta !== 0 && panels[panelIndex].size + delta >= _this.getPanelMinSize(panelIndex, panels) && panels[panelIndex + 1].size - delta >= _this.getPanelMinSize(panelIndex + 1, panels)) {\n            resultDelta = _this.resizePanel(panelIndex, -delta, panels);\n          }\n        }\n      } // return how much this panel actually resized\n\n\n      return resultDelta;\n    };\n\n    _this.getPanelMinSize = function (panelIndex, panels) {\n      if (panels[panelIndex].resize === 'fixed') {\n        if (!panels[panelIndex].fixedSize) {\n          panels[panelIndex].fixedSize = panels[panelIndex].size;\n        }\n\n        return panels[panelIndex].fixedSize;\n      }\n\n      return panels[panelIndex].minSize;\n    };\n\n    _this.getPanelMaxSize = function (panelIndex, panels) {\n      if (panels[panelIndex].resize === 'fixed') {\n        if (!panels[panelIndex].fixedSize) {\n          panels[panelIndex].fixedSize = panels[panelIndex].size;\n        }\n\n        return panels[panelIndex].fixedSize;\n      }\n\n      return panels[panelIndex].maxSize; // return 0;\n    };\n\n    _this.getPanelGroupMinSize = function (spacing) {\n      var size = 0;\n\n      for (var i = 0; i < _this.state.panels.length; i++) {\n        size += _this.getPanelMinSize(i, _this.state.panels);\n      }\n\n      return size + (_this.state.panels.length - 1) * spacing;\n    };\n\n    _this.getPanelGroupMaxSize = function (spacing) {\n      var size = 0;\n\n      for (var i = 0; i < _this.state.panels.length; i++) {\n        size += _this.getPanelMaxSize(i, _this.state.panels);\n      }\n\n      return size + (_this.state.panels.length - 1) * spacing;\n    };\n\n    _this.setPanelSize = function (panelIndex, size, callback, node) {\n      if (!_this.node && node) {\n        // due to timing child elements may have parent node first!\n        _this.node = node;\n      }\n\n      size = _this.props.direction === 'column' ? size.y : size.x;\n\n      if (size !== _this.state.panels[panelIndex].size) {\n        var tempPanels = _this.state.panels.map(function (panel) {\n          return _extends({}, panel);\n        }); // make sure we can actually resize this panel this small\n\n\n        if (size < tempPanels[panelIndex].minSize) {\n          var diff = tempPanels[panelIndex].minSize - size;\n          tempPanels[panelIndex].size = tempPanels[panelIndex].minSize; // 1) Find all of the dynamic panels that we can resize and\n          // decrease them until the difference is gone\n\n          for (var i = 0; i < tempPanels.length; i += 1) {\n            if (i !== panelIndex && tempPanels[i].resize === 'dynamic') {\n              var available = tempPanels[i].size - tempPanels[i].minSize;\n              var cut = Math.min(diff, available);\n              tempPanels[i].size -= cut; // if the difference is gone then we are done!\n\n              diff -= cut;\n\n              if (diff === 0) {\n                break;\n              }\n            }\n          }\n        } else {\n          tempPanels[panelIndex].size = size;\n        }\n\n        _this.setState({\n          panels: tempPanels\n        });\n\n        _this.onUpdate(tempPanels);\n\n        if (panelIndex > 0) {\n          _this.handleResize(panelIndex - 1, {\n            x: 0,\n            y: 0\n          });\n        } else if (_this.state.panels.length > 2) {\n          _this.handleResize(panelIndex + 1, {\n            x: 0,\n            y: 0\n          });\n        }\n\n        if (callback) {\n          callback();\n        }\n      }\n    };\n\n    _this.state = _this.loadPanels(_this.props);\n    return _this;\n  } // reload panel configuration if props update\n\n\n  PanelGroup.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    var nextPanels = nextProps.panelWidths; // Only update from props if we're supplying the props in the first place\n\n    if (nextPanels.length) {\n      // if the panel array is a different size we know to update\n      if (this.state.panels.length !== nextPanels.length) {\n        this.setState(this.loadPanels(nextProps));\n      } else {\n        // otherwise we need to iterate to spot any difference\n        for (var i = 0; i < nextPanels.length; i++) {\n          if (this.state.panels[i].size !== nextPanels[i].size || this.state.panels[i].minSize !== nextPanels[i].minSize || this.state.panels[i].maxSize !== nextPanels[i].maxSize || this.state.panels[i].resize !== nextPanels[i].resize) {\n            this.setState(this.loadPanels(nextProps));\n            break;\n          }\n        }\n      }\n    }\n  }; // load provided props into state\n  // Pass internal state out if there's a callback for it\n  // Useful for saving panel configuration\n  // For styling, track which direction to apply sizing to\n\n\n  PanelGroup.prototype.getStyle = function getStyle() {\n    var _container;\n\n    var container = (_container = {\n      width: '100%',\n      height: '100%'\n    }, _container['min' + this.getSizeDirection(true)] = this.getPanelGroupMinSize(this.props.spacing), _container.display = 'flex', _container.flexDirection = this.props.direction, _container.flexGrow = 1, _container);\n    return {\n      container: container,\n      panel: {\n        flexGrow: 0,\n        display: 'flex'\n      }\n    };\n  };\n\n  PanelGroup.prototype.getPanelStyle = function getPanelStyle(index) {\n    var _extends2;\n\n    var _props = this.props,\n        direction = _props.direction,\n        panelColor = _props.panelColor;\n    var panel = this.state.panels[index];\n    var style = panel.style; // setting up the style for this panel.  Should probably be handled\n    // in the child component, but this was easier for now\n\n    var newPanelStyle = _extends((_extends2 = {}, _extends2[this.getSizeDirection()] = panel.size, _extends2[direction === 'row' ? 'height' : 'width'] = '100%', _extends2['min' + this.getSizeDirection(true)] = panel.resize === 'stretch' ? 0 : panel.size, _extends2.flexGrow = panel.resize === 'stretch' ? 1 : 0, _extends2.flexShrink = panel.resize === 'stretch' ? 1 : 0, _extends2.display = 'flex', _extends2.overflow = 'hidden', _extends2.position = 'relative', _extends2), style);\n\n    if (panelColor !== null) {\n      // patch in the background color if it was supplied as a prop\n      newPanelStyle = _extends({}, newPanelStyle, {\n        backgroundColor: panelColor\n      });\n    }\n\n    return newPanelStyle;\n  };\n\n  PanelGroup.prototype.createPanelProps = function createPanelProps(_ref) {\n    var panelStyle = _ref.panelStyle,\n        index = _ref.index,\n        initialChildren = _ref.initialChildren;\n    var panelState = this.state.panels[index];\n    var stretchIncluded = false; // give position info to children\n\n    var metadata = {\n      isFirst: index === 0,\n      isLast: index === initialChildren.length - 1,\n      resize: panelState.resize,\n      // window resize handler if this panel is stretchy\n      onWindowResize: panelState.resize === 'stretch' ? this.setPanelSize : null\n    }; // if none of the panels included was stretchy, make the last one stretchy\n\n    if (panelState.resize === 'stretch') stretchIncluded = true;\n    if (!stretchIncluded && metadata.isLast) metadata.resize = 'stretch';\n    return _extends({\n      style: panelStyle,\n      key: index,\n      panelID: index\n    }, metadata);\n  };\n\n  PanelGroup.prototype.createPanel = function createPanel(_ref2) {\n    var panelStyle = _ref2.panelStyle,\n        index = _ref2.index,\n        initialChildren = _ref2.initialChildren;\n    var Klass = this.getPanelClass();\n    return React.createElement(Klass, this.createPanelProps({\n      panelStyle: panelStyle,\n      index: index,\n      initialChildren: initialChildren\n    }), initialChildren[index]);\n  }; // eslint-disable-next-line class-methods-use-this\n\n\n  PanelGroup.prototype.getPanelClass = function getPanelClass() {\n    // mainly for accessing default props of panels\n    return Panel;\n  };\n\n  PanelGroup.prototype.maybeDivide = function maybeDivide(_ref3) {\n    var initialChildren = _ref3.initialChildren,\n        newChildren = _ref3.newChildren,\n        index = _ref3.index; // add a handle between panels\n\n    if (index < initialChildren.length - 1) {\n      newChildren.push(React.createElement(Divider, {\n        borderColor: this.props.borderColor,\n        key: 'divider' + index,\n        panelID: index,\n        handleResize: this.handleResize,\n        dividerWidth: this.props.spacing,\n        direction: this.props.direction,\n        showHandles: this.props.showHandles,\n        onResizeStart: this.onResizeStart,\n        onResizeEnd: this.onResizeEnd\n      }));\n    }\n  }; // Entry point for resizing panels.\n  // We clone the panel array and perform operations on it so we can\n  // setState after the recursive operations are finished\n  // Recursive panel resizing so we can push other panels out of the way\n  // if we've exceeded the target panel's extents\n  // Utility function for getting min pixel size of panel\n  // Utility function for getting max pixel size of panel\n  // Utility function for getting min pixel size of the entire panel group\n  // Utility function for getting max pixel size of the entire panel group\n  // Hard-set a panel's size\n  // Used to recalculate a stretchy panel when the window is resized\n\n\n  PanelGroup.prototype.render = function render() {\n    var _this2 = this;\n\n    var children = this.props.children;\n    var style = this.getStyle(); // lets build up a new children array with added resize borders\n\n    var initialChildren = React.Children.toArray(children);\n    var newChildren = [];\n\n    for (var i = 0; i < initialChildren.length; i++) {\n      var panelStyle = this.getPanelStyle(i);\n      var newPanel = this.createPanel({\n        panelStyle: panelStyle,\n        index: i,\n        initialChildren: initialChildren\n      });\n      newChildren.push(newPanel);\n      this.maybeDivide({\n        initialChildren: initialChildren,\n        newChildren: newChildren,\n        index: i\n      });\n    }\n\n    return React.createElement('div', {\n      className: 'panelGroup',\n      style: style.container,\n      ref: function ref(node) {\n        _this2.node = node;\n      }\n    }, newChildren);\n  };\n\n  return PanelGroup;\n}(React.Component), _class.defaultProps = {\n  spacing: 1,\n  direction: 'row',\n  panelWidths: [],\n  onUpdate: undefined,\n  onResizeStart: undefined,\n  onResizeEnd: undefined,\n  panelColor: undefined,\n  borderColor: undefined,\n  showHandles: false\n}, _temp);\nexport { PanelGroup as default };\nPanelGroup.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  spacing: PropTypes.number,\n  direction: PropTypes.string,\n  panelWidths: PropTypes.array,\n  children: PropTypes.oneOfType([PropTypes.array, PropTypes.object]).isRequired,\n  onUpdate: PropTypes.func,\n  onResizeStart: PropTypes.func,\n  onResizeEnd: PropTypes.func,\n  panelColor: PropTypes.string,\n  borderColor: PropTypes.string,\n  showHandles: PropTypes.bool\n} : {};","map":{"version":3,"sources":["C:/Users/jacob/Comp-Coder/node_modules/react-panelgroup/es/PanelGroup.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","_class","_temp","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","React","PropTypes","Panel","Divider","PanelGroup","_React$Component","_len","args","Array","_key","_this","apply","concat","defaultResize","props","index","resize","panelWidths","size","loadPanels","panels","children","defaultSize","defaultMinSize","defaultMaxSize","stretchIncluded","Children","toArray","widthObj","undefined","minSize","maxSize","snap","style","getPanelClass","defaultProps","push","onUpdate","slice","onResizeStart","state","onResizeEnd","getSizeDirection","caps","direction","handleResize","delta","tempPanels","returnDelta","resizePanel","x","y","setState","panelIndex","masterSize","iti","boundingRect","node","getBoundingClientRect","boundingSize","height","width","spacing","Math","abs","minsize","maxsize","resultDelta","getPanelMinSize","getPanelMaxSize","_i","fixedSize","getPanelGroupMinSize","getPanelGroupMaxSize","setPanelSize","callback","map","panel","diff","available","cut","min","componentWillReceiveProps","nextProps","nextPanels","getStyle","_container","container","display","flexDirection","flexGrow","getPanelStyle","_extends2","_props","panelColor","newPanelStyle","flexShrink","overflow","position","backgroundColor","createPanelProps","_ref","panelStyle","initialChildren","panelState","metadata","isFirst","isLast","onWindowResize","panelID","createPanel","_ref2","Klass","createElement","maybeDivide","_ref3","newChildren","borderColor","dividerWidth","showHandles","render","_this2","newPanel","className","ref","Component","default","propTypes","process","env","NODE_ENV","number","string","array","oneOfType","object","isRequired","func","bool"],"mappings":"AAAA,IAAIA,QAAQ,GAAGC,MAAM,CAACC,MAAP,IAAiB,UAAUC,MAAV,EAAkB;AAAE,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGC,SAAS,CAACC,MAA9B,EAAsCF,CAAC,EAAvC,EAA2C;AAAE,QAAIG,MAAM,GAAGF,SAAS,CAACD,CAAD,CAAtB;;AAA2B,SAAK,IAAII,GAAT,IAAgBD,MAAhB,EAAwB;AAAE,UAAIN,MAAM,CAACQ,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCJ,MAArC,EAA6CC,GAA7C,CAAJ,EAAuD;AAAEL,QAAAA,MAAM,CAACK,GAAD,CAAN,GAAcD,MAAM,CAACC,GAAD,CAApB;AAA4B;AAAE;AAAE;;AAAC,SAAOL,MAAP;AAAgB,CAAhQ;;AAEA,IAAIS,MAAJ,EAAYC,KAAZ;;AAEA,SAASC,eAAT,CAAyBC,QAAzB,EAAmCC,WAAnC,EAAgD;AAAE,MAAI,EAAED,QAAQ,YAAYC,WAAtB,CAAJ,EAAwC;AAAE,UAAM,IAAIC,SAAJ,CAAc,mCAAd,CAAN;AAA2D;AAAE;;AAEzJ,SAASC,0BAAT,CAAoCC,IAApC,EAA0CR,IAA1C,EAAgD;AAAE,MAAI,CAACQ,IAAL,EAAW;AAAE,UAAM,IAAIC,cAAJ,CAAmB,2DAAnB,CAAN;AAAwF;;AAAC,SAAOT,IAAI,KAAK,OAAOA,IAAP,KAAgB,QAAhB,IAA4B,OAAOA,IAAP,KAAgB,UAAjD,CAAJ,GAAmEA,IAAnE,GAA0EQ,IAAjF;AAAwF;;AAEhP,SAASE,SAAT,CAAmBC,QAAnB,EAA6BC,UAA7B,EAAyC;AAAE,MAAI,OAAOA,UAAP,KAAsB,UAAtB,IAAoCA,UAAU,KAAK,IAAvD,EAA6D;AAAE,UAAM,IAAIN,SAAJ,CAAc,6DAA6D,OAAOM,UAAlF,CAAN;AAAsG;;AAACD,EAAAA,QAAQ,CAACb,SAAT,GAAqBR,MAAM,CAACuB,MAAP,CAAcD,UAAU,IAAIA,UAAU,CAACd,SAAvC,EAAkD;AAAEgB,IAAAA,WAAW,EAAE;AAAEC,MAAAA,KAAK,EAAEJ,QAAT;AAAmBK,MAAAA,UAAU,EAAE,KAA/B;AAAsCC,MAAAA,QAAQ,EAAE,IAAhD;AAAsDC,MAAAA,YAAY,EAAE;AAApE;AAAf,GAAlD,CAArB;AAAqK,MAAIN,UAAJ,EAAgBtB,MAAM,CAAC6B,cAAP,GAAwB7B,MAAM,CAAC6B,cAAP,CAAsBR,QAAtB,EAAgCC,UAAhC,CAAxB,GAAsED,QAAQ,CAACS,SAAT,GAAqBR,UAA3F;AAAwG;;AAE9e,OAAOS,KAAP,MAAkB,OAAlB;AACA,OAAOC,SAAP,MAAsB,YAAtB;AAEA,OAAOC,KAAP,MAAkB,SAAlB;AACA,OAAOC,OAAP,MAAoB,WAApB;AAEA,SAASA,OAAT,EAAkBD,KAAlB;AAEA,IAAIE,UAAU,IAAIvB,KAAK,GAAGD,MAAM,GAAG,UAAUyB,gBAAV,EAA4B;AAC7DhB,EAAAA,SAAS,CAACe,UAAD,EAAaC,gBAAb,CAAT,CAD6D,CAG7D;;;AACA,WAASD,UAAT,GAAsB;AACpBtB,IAAAA,eAAe,CAAC,IAAD,EAAOsB,UAAP,CAAf;;AAEA,SAAK,IAAIE,IAAI,GAAGjC,SAAS,CAACC,MAArB,EAA6BiC,IAAI,GAAGC,KAAK,CAACF,IAAD,CAAzC,EAAiDG,IAAI,GAAG,CAA7D,EAAgEA,IAAI,GAAGH,IAAvE,EAA6EG,IAAI,EAAjF,EAAqF;AACnFF,MAAAA,IAAI,CAACE,IAAD,CAAJ,GAAapC,SAAS,CAACoC,IAAD,CAAtB;AACD;;AAED,QAAIC,KAAK,GAAGxB,0BAA0B,CAAC,IAAD,EAAOmB,gBAAgB,CAAC1B,IAAjB,CAAsBgC,KAAtB,CAA4BN,gBAA5B,EAA8C,CAAC,IAAD,EAAOO,MAAP,CAAcL,IAAd,CAA9C,CAAP,CAAtC;;AAEAG,IAAAA,KAAK,CAACG,aAAN,GAAsB,UAAUC,KAAV,EAAiBC,KAAjB,EAAwBF,aAAxB,EAAuC;AAC3D,UAAIG,MAAM,GAAGH,aAAb;;AACA,UAAIC,KAAK,CAACG,WAAN,CAAkBF,KAAlB,EAAyBC,MAA7B,EAAqC;AACnCA,QAAAA,MAAM,GAAGF,KAAK,CAACG,WAAN,CAAkBF,KAAlB,EAAyBC,MAAlC,CADmC,CACO;AAC3C,OAFD,MAEO;AACLA,QAAAA,MAAM,GAAGF,KAAK,CAACG,WAAN,CAAkBF,KAAlB,EAAyBG,IAAzB,GAAgC,SAAhC,GAA4CF,MAArD;AACD;;AACD,aAAOA,MAAP;AACD,KARD;;AAUAN,IAAAA,KAAK,CAACS,UAAN,GAAmB,UAAUL,KAAV,EAAiB;AAClC,UAAIM,MAAM,GAAG,EAAb;;AAEA,UAAIN,KAAK,CAACO,QAAV,EAAoB;AAClB;AACA,YAAIC,WAAW,GAAG,GAAlB;AACA,YAAIC,cAAc,GAAG,EAArB;AACA,YAAIC,cAAc,GAAG,CAArB;AACA,YAAIX,aAAa,GAAG,SAApB;AAEA,YAAIY,eAAe,GAAG,KAAtB;AACA,YAAIJ,QAAQ,GAAGrB,KAAK,CAAC0B,QAAN,CAAeC,OAAf,CAAuBb,KAAK,CAACO,QAA7B,CAAf;;AAEA,aAAK,IAAIjD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiD,QAAQ,CAAC/C,MAA7B,EAAqCF,CAAC,EAAtC,EAA0C;AACxC,cAAIA,CAAC,GAAG0C,KAAK,CAACG,WAAN,CAAkB3C,MAAtB,IAAgCwC,KAAK,CAACG,WAAN,CAAkB7C,CAAlB,CAApC,EAA0D;AACxD,gBAAIwD,QAAQ,GAAG;AACbV,cAAAA,IAAI,EAAEJ,KAAK,CAACG,WAAN,CAAkB7C,CAAlB,EAAqB8C,IAArB,KAA8BW,SAA9B,GAA0Cf,KAAK,CAACG,WAAN,CAAkB7C,CAAlB,EAAqB8C,IAA/D,GAAsEI,WAD/D;AAEbQ,cAAAA,OAAO,EAAEhB,KAAK,CAACG,WAAN,CAAkB7C,CAAlB,EAAqB0D,OAArB,KAAiCD,SAAjC,GAA6Cf,KAAK,CAACG,WAAN,CAAkB7C,CAAlB,EAAqB0D,OAAlE,GAA4EP,cAFxE;AAGbQ,cAAAA,OAAO,EAAEjB,KAAK,CAACG,WAAN,CAAkB7C,CAAlB,EAAqB2D,OAArB,KAAiCF,SAAjC,GAA6Cf,KAAK,CAACG,WAAN,CAAkB7C,CAAlB,EAAqB2D,OAAlE,GAA4EP,cAHxE;AAIbR,cAAAA,MAAM,EAAEN,KAAK,CAACG,aAAN,CAAoBC,KAApB,EAA2B1C,CAA3B,EAA8ByC,aAA9B,CAJK;AAKbmB,cAAAA,IAAI,EAAElB,KAAK,CAACG,WAAN,CAAkB7C,CAAlB,EAAqB4D,IAArB,KAA8BH,SAA9B,GAA0Cf,KAAK,CAACG,WAAN,CAAkB7C,CAAlB,EAAqB4D,IAA/D,GAAsE,EAL/D;AAMbC,cAAAA,KAAK,EAAEjE,QAAQ,CAAC,EAAD,EAAK0C,KAAK,CAACwB,aAAN,GAAsBC,YAAtB,CAAmCF,KAAxC,EAA+CnB,KAAK,CAACG,WAAN,CAAkB7C,CAAlB,EAAqB6D,KAArB,IAA8B,EAA7E;AANF,aAAf;AAQAb,YAAAA,MAAM,CAACgB,IAAP,CAAYR,QAAZ;AACD,WAVD,MAUO;AACL;AACAR,YAAAA,MAAM,CAACgB,IAAP,CAAY;AACVlB,cAAAA,IAAI,EAAEI,WADI;AAEVN,cAAAA,MAAM,EAAEH,aAFE;AAGViB,cAAAA,OAAO,EAAEP,cAHC;AAIVQ,cAAAA,OAAO,EAAEP,cAJC;AAKVQ,cAAAA,IAAI,EAAE,EALI;AAMVC,cAAAA,KAAK,EAAE;AANG,aAAZ;AAQD,WArBuC,CAuBxC;;;AACA,cAAIb,MAAM,CAAChD,CAAD,CAAN,CAAU4C,MAAV,KAAqB,SAAzB,EAAoCS,eAAe,GAAG,IAAlB;AACpC,cAAI,CAACA,eAAD,IAAoBrD,CAAC,KAAKiD,QAAQ,CAAC/C,MAAT,GAAkB,CAAhD,EAAmD8C,MAAM,CAAChD,CAAD,CAAN,CAAU4C,MAAV,GAAmB,SAAnB;AACpD;AACF;;AAED,aAAO;AACLI,QAAAA,MAAM,EAAEA;AADH,OAAP;AAGD,KA7CD;;AA+CAV,IAAAA,KAAK,CAAC2B,QAAN,GAAiB,UAAUjB,MAAV,EAAkB;AACjC,UAAIV,KAAK,CAACI,KAAN,CAAYuB,QAAhB,EAA0B;AACxB3B,QAAAA,KAAK,CAACI,KAAN,CAAYuB,QAAZ,CAAqBjB,MAAM,CAACkB,KAAP,EAArB;AACD;AACF,KAJD;;AAMA5B,IAAAA,KAAK,CAAC6B,aAAN,GAAsB,YAAY;AAChC,UAAI7B,KAAK,CAACI,KAAN,CAAYyB,aAAhB,EAA+B;AAC7B;AACA7B,QAAAA,KAAK,CAACI,KAAN,CAAYyB,aAAZ,CAA0B7B,KAAK,CAAC8B,KAAN,CAAYpB,MAAZ,CAAmBkB,KAAnB,EAA1B;AACD;AACF,KALD;;AAOA5B,IAAAA,KAAK,CAAC+B,WAAN,GAAoB,YAAY;AAC9B,UAAI/B,KAAK,CAACI,KAAN,CAAY2B,WAAhB,EAA6B;AAC3B/B,QAAAA,KAAK,CAACI,KAAN,CAAY2B,WAAZ,CAAwB/B,KAAK,CAAC8B,KAAN,CAAYpB,MAAZ,CAAmBkB,KAAnB,EAAxB;AACD;AACF,KAJD;;AAMA5B,IAAAA,KAAK,CAACgC,gBAAN,GAAyB,UAAUC,IAAV,EAAgB;AACvC,UAAIA,IAAJ,EAAU;AACR,eAAOjC,KAAK,CAACI,KAAN,CAAY8B,SAAZ,KAA0B,QAA1B,GAAqC,QAArC,GAAgD,OAAvD;AACD;;AACD,aAAOlC,KAAK,CAACI,KAAN,CAAY8B,SAAZ,KAA0B,QAA1B,GAAqC,QAArC,GAAgD,OAAvD;AACD,KALD;;AAOAlC,IAAAA,KAAK,CAACmC,YAAN,GAAqB,UAAUzE,CAAV,EAAa0E,KAAb,EAAoB;AACvC,UAAIC,UAAU,GAAGrC,KAAK,CAAC8B,KAAN,CAAYpB,MAAZ,CAAmBkB,KAAnB,EAAjB;;AACA,UAAIU,WAAW,GAAGtC,KAAK,CAACuC,WAAN,CAAkB7E,CAAlB,EAAqBsC,KAAK,CAACI,KAAN,CAAY8B,SAAZ,KAA0B,KAA1B,GAAkCE,KAAK,CAACI,CAAxC,GAA4CJ,KAAK,CAACK,CAAvE,EAA0EJ,UAA1E,CAAlB;;AACArC,MAAAA,KAAK,CAAC0C,QAAN,CAAe;AAAEhC,QAAAA,MAAM,EAAE2B;AAAV,OAAf;;AACArC,MAAAA,KAAK,CAAC2B,QAAN,CAAeU,UAAf;;AACA,aAAOC,WAAP;AACD,KAND;;AAQAtC,IAAAA,KAAK,CAACuC,WAAN,GAAoB,UAAUI,UAAV,EAAsBP,KAAtB,EAA6B1B,MAA7B,EAAqC;AACvD;AACA,UAAIkC,UAAU,GAAG,CAAjB;;AACA,WAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGnC,MAAM,CAAC9C,MAA/B,EAAuCiF,GAAG,IAAI,CAA9C,EAAiD;AAC/CD,QAAAA,UAAU,IAAIlC,MAAM,CAACmC,GAAD,CAAN,CAAYrC,IAA1B;AACD;;AACD,UAAIsC,YAAY,GAAG9C,KAAK,CAAC+C,IAAN,CAAWC,qBAAX,EAAnB;;AACA,UAAIC,YAAY,GAAG,CAACjD,KAAK,CAACI,KAAN,CAAY8B,SAAZ,KAA0B,QAA1B,GAAqCY,YAAY,CAACI,MAAlD,GAA2DJ,YAAY,CAACK,KAAzE,IAAkFnD,KAAK,CAACI,KAAN,CAAYgD,OAAZ,IAAuBpD,KAAK,CAACI,KAAN,CAAYO,QAAZ,CAAqB/C,MAArB,GAA8B,CAArD,CAArG;;AACA,UAAIyF,IAAI,CAACC,GAAL,CAASL,YAAY,GAAGL,UAAxB,KAAuC,IAA3C,EAAiD;AAC/C;AACA;AAEA;AACAlC,QAAAA,MAAM,CAACiC,UAAD,CAAN,CAAmBnC,IAAnB,IAA2ByC,YAAY,GAAGL,UAA1C;AACD;;AAED,UAAIW,OAAO,GAAG,KAAK,CAAnB;AACA,UAAIC,OAAO,GAAG,KAAK,CAAnB,CAjBuD,CAmBvD;AACA;;AACA,UAAIC,WAAW,GAAGrB,KAAlB,CArBuD,CAuBvD;;AACA1B,MAAAA,MAAM,CAACiC,UAAD,CAAN,CAAmBnC,IAAnB,IAA2B4B,KAA3B;AACA1B,MAAAA,MAAM,CAACiC,UAAU,GAAG,CAAd,CAAN,CAAuBnC,IAAvB,IAA+B4B,KAA/B,CAzBuD,CA2BvD;;AACAmB,MAAAA,OAAO,GAAGvD,KAAK,CAAC0D,eAAN,CAAsBf,UAAtB,EAAkCjC,MAAlC,CAAV;AACA8C,MAAAA,OAAO,GAAGxD,KAAK,CAAC2D,eAAN,CAAsBhB,UAAtB,EAAkCjC,MAAlC,CAAV,CA7BuD,CA+BvD;;AACA,UAAIA,MAAM,CAACiC,UAAD,CAAN,CAAmBnC,IAAnB,GAA0B+C,OAA9B,EAAuC;AACrCnB,QAAAA,KAAK,GAAGmB,OAAO,GAAG7C,MAAM,CAACiC,UAAD,CAAN,CAAmBnC,IAArC;;AAEA,YAAImC,UAAU,KAAK,CAAnB,EAAsB;AACpBc,UAAAA,WAAW,GAAGzD,KAAK,CAACuC,WAAN,CAAkBI,UAAlB,EAA8BP,KAA9B,EAAqC1B,MAArC,CAAd;AACD,SAFD,MAEO;AACL+C,UAAAA,WAAW,GAAGzD,KAAK,CAACuC,WAAN,CAAkBI,UAAU,GAAG,CAA/B,EAAkC,CAACP,KAAnC,EAA0C1B,MAA1C,CAAd;AACD;AACF,OAxCsD,CA0CvD;;;AACA,UAAI8C,OAAO,KAAK,CAAZ,IAAiB9C,MAAM,CAACiC,UAAD,CAAN,CAAmBnC,IAAnB,GAA0BgD,OAA/C,EAAwD;AACtDpB,QAAAA,KAAK,GAAG1B,MAAM,CAACiC,UAAD,CAAN,CAAmBnC,IAAnB,GAA0BgD,OAAlC;;AAEA,YAAIb,UAAU,KAAK,CAAnB,EAAsB;AACpBc,UAAAA,WAAW,GAAGzD,KAAK,CAACuC,WAAN,CAAkBI,UAAlB,EAA8B,CAACP,KAA/B,EAAsC1B,MAAtC,CAAd;AACD,SAFD,MAEO;AACL+C,UAAAA,WAAW,GAAGzD,KAAK,CAACuC,WAAN,CAAkBI,UAAU,GAAG,CAA/B,EAAkCP,KAAlC,EAAyC1B,MAAzC,CAAd;AACD;AACF,OAnDsD,CAqDvD;;;AACA6C,MAAAA,OAAO,GAAGvD,KAAK,CAAC0D,eAAN,CAAsBf,UAAU,GAAG,CAAnC,EAAsCjC,MAAtC,CAAV;AACA8C,MAAAA,OAAO,GAAGxD,KAAK,CAAC2D,eAAN,CAAsBhB,UAAU,GAAG,CAAnC,EAAsCjC,MAAtC,CAAV,CAvDuD,CAyDvD;;AACA,UAAIA,MAAM,CAACiC,UAAU,GAAG,CAAd,CAAN,CAAuBnC,IAAvB,GAA8B+C,OAAlC,EAA2C;AACzCnB,QAAAA,KAAK,GAAGmB,OAAO,GAAG7C,MAAM,CAACiC,UAAU,GAAG,CAAd,CAAN,CAAuBnC,IAAzC;;AAEA,YAAImC,UAAU,GAAG,CAAb,KAAmBjC,MAAM,CAAC9C,MAAP,GAAgB,CAAvC,EAA0C;AACxC6F,UAAAA,WAAW,GAAGzD,KAAK,CAACuC,WAAN,CAAkBI,UAAlB,EAA8B,CAACP,KAA/B,EAAsC1B,MAAtC,CAAd;AACD,SAFD,MAEO;AACL+C,UAAAA,WAAW,GAAGzD,KAAK,CAACuC,WAAN,CAAkBI,UAAU,GAAG,CAA/B,EAAkCP,KAAlC,EAAyC1B,MAAzC,CAAd;AACD;AACF,OAlEsD,CAoEvD;;;AACA,UAAI8C,OAAO,KAAK,CAAZ,IAAiB9C,MAAM,CAACiC,UAAU,GAAG,CAAd,CAAN,CAAuBnC,IAAvB,GAA8BgD,OAAnD,EAA4D;AAC1DpB,QAAAA,KAAK,GAAG1B,MAAM,CAACiC,UAAU,GAAG,CAAd,CAAN,CAAuBnC,IAAvB,GAA8BgD,OAAtC;;AAEA,YAAIb,UAAU,GAAG,CAAb,KAAmBjC,MAAM,CAAC9C,MAAP,GAAgB,CAAvC,EAA0C;AACxC6F,UAAAA,WAAW,GAAGzD,KAAK,CAACuC,WAAN,CAAkBI,UAAlB,EAA8BP,KAA9B,EAAqC1B,MAArC,CAAd;AACD,SAFD,MAEO;AACL+C,UAAAA,WAAW,GAAGzD,KAAK,CAACuC,WAAN,CAAkBI,UAAU,GAAG,CAA/B,EAAkC,CAACP,KAAnC,EAA0C1B,MAA1C,CAAd;AACD;AACF,OA7EsD,CA+EvD;;;AACA,WAAK,IAAIhD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGgD,MAAM,CAACiC,UAAD,CAAN,CAAmBrB,IAAnB,CAAwB1D,MAA5C,EAAoDF,CAAC,EAArD,EAAyD;AACvD,YAAI2F,IAAI,CAACC,GAAL,CAAS5C,MAAM,CAACiC,UAAD,CAAN,CAAmBrB,IAAnB,CAAwB5D,CAAxB,IAA6BgD,MAAM,CAACiC,UAAD,CAAN,CAAmBnC,IAAzD,IAAiE,EAArE,EAAyE;AACvE4B,UAAAA,KAAK,GAAG1B,MAAM,CAACiC,UAAD,CAAN,CAAmBrB,IAAnB,CAAwB5D,CAAxB,IAA6BgD,MAAM,CAACiC,UAAD,CAAN,CAAmBnC,IAAxD;;AAEA,cAAI4B,KAAK,KAAK,CAAV,IAAe1B,MAAM,CAACiC,UAAD,CAAN,CAAmBnC,IAAnB,GAA0B4B,KAA1B,IAAmCpC,KAAK,CAAC0D,eAAN,CAAsBf,UAAtB,EAAkCjC,MAAlC,CAAlD,IAA+FA,MAAM,CAACiC,UAAU,GAAG,CAAd,CAAN,CAAuBnC,IAAvB,GAA8B4B,KAA9B,IAAuCpC,KAAK,CAAC0D,eAAN,CAAsBf,UAAU,GAAG,CAAnC,EAAsCjC,MAAtC,CAA1I,EAAyL;AACvL+C,YAAAA,WAAW,GAAGzD,KAAK,CAACuC,WAAN,CAAkBI,UAAlB,EAA8BP,KAA9B,EAAqC1B,MAArC,CAAd;AACD;AACF;AACF,OAxFsD,CA0FvD;;;AACA,WAAK,IAAIkD,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGlD,MAAM,CAACiC,UAAU,GAAG,CAAd,CAAN,CAAuBrB,IAAvB,CAA4B1D,MAAlD,EAA0DgG,EAAE,EAA5D,EAAgE;AAC9D,YAAIP,IAAI,CAACC,GAAL,CAAS5C,MAAM,CAACiC,UAAU,GAAG,CAAd,CAAN,CAAuBrB,IAAvB,CAA4BsC,EAA5B,IAAkClD,MAAM,CAACiC,UAAU,GAAG,CAAd,CAAN,CAAuBnC,IAAlE,IAA0E,EAA9E,EAAkF;AAChF4B,UAAAA,KAAK,GAAG1B,MAAM,CAACiC,UAAU,GAAG,CAAd,CAAN,CAAuBrB,IAAvB,CAA4BsC,EAA5B,IAAkClD,MAAM,CAACiC,UAAU,GAAG,CAAd,CAAN,CAAuBnC,IAAjE;;AAEA,cAAI4B,KAAK,KAAK,CAAV,IAAe1B,MAAM,CAACiC,UAAD,CAAN,CAAmBnC,IAAnB,GAA0B4B,KAA1B,IAAmCpC,KAAK,CAAC0D,eAAN,CAAsBf,UAAtB,EAAkCjC,MAAlC,CAAlD,IAA+FA,MAAM,CAACiC,UAAU,GAAG,CAAd,CAAN,CAAuBnC,IAAvB,GAA8B4B,KAA9B,IAAuCpC,KAAK,CAAC0D,eAAN,CAAsBf,UAAU,GAAG,CAAnC,EAAsCjC,MAAtC,CAA1I,EAAyL;AACvL+C,YAAAA,WAAW,GAAGzD,KAAK,CAACuC,WAAN,CAAkBI,UAAlB,EAA8B,CAACP,KAA/B,EAAsC1B,MAAtC,CAAd;AACD;AACF;AACF,OAnGsD,CAqGvD;;;AACA,aAAO+C,WAAP;AACD,KAvGD;;AAyGAzD,IAAAA,KAAK,CAAC0D,eAAN,GAAwB,UAAUf,UAAV,EAAsBjC,MAAtB,EAA8B;AACpD,UAAIA,MAAM,CAACiC,UAAD,CAAN,CAAmBrC,MAAnB,KAA8B,OAAlC,EAA2C;AACzC,YAAI,CAACI,MAAM,CAACiC,UAAD,CAAN,CAAmBkB,SAAxB,EAAmC;AACjCnD,UAAAA,MAAM,CAACiC,UAAD,CAAN,CAAmBkB,SAAnB,GAA+BnD,MAAM,CAACiC,UAAD,CAAN,CAAmBnC,IAAlD;AACD;;AACD,eAAOE,MAAM,CAACiC,UAAD,CAAN,CAAmBkB,SAA1B;AACD;;AACD,aAAOnD,MAAM,CAACiC,UAAD,CAAN,CAAmBvB,OAA1B;AACD,KARD;;AAUApB,IAAAA,KAAK,CAAC2D,eAAN,GAAwB,UAAUhB,UAAV,EAAsBjC,MAAtB,EAA8B;AACpD,UAAIA,MAAM,CAACiC,UAAD,CAAN,CAAmBrC,MAAnB,KAA8B,OAAlC,EAA2C;AACzC,YAAI,CAACI,MAAM,CAACiC,UAAD,CAAN,CAAmBkB,SAAxB,EAAmC;AACjCnD,UAAAA,MAAM,CAACiC,UAAD,CAAN,CAAmBkB,SAAnB,GAA+BnD,MAAM,CAACiC,UAAD,CAAN,CAAmBnC,IAAlD;AACD;;AACD,eAAOE,MAAM,CAACiC,UAAD,CAAN,CAAmBkB,SAA1B;AACD;;AACD,aAAOnD,MAAM,CAACiC,UAAD,CAAN,CAAmBtB,OAA1B,CAPoD,CAQpD;AACD,KATD;;AAWArB,IAAAA,KAAK,CAAC8D,oBAAN,GAA6B,UAAUV,OAAV,EAAmB;AAC9C,UAAI5C,IAAI,GAAG,CAAX;;AACA,WAAK,IAAI9C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGsC,KAAK,CAAC8B,KAAN,CAAYpB,MAAZ,CAAmB9C,MAAvC,EAA+CF,CAAC,EAAhD,EAAoD;AAClD8C,QAAAA,IAAI,IAAIR,KAAK,CAAC0D,eAAN,CAAsBhG,CAAtB,EAAyBsC,KAAK,CAAC8B,KAAN,CAAYpB,MAArC,CAAR;AACD;;AACD,aAAOF,IAAI,GAAG,CAACR,KAAK,CAAC8B,KAAN,CAAYpB,MAAZ,CAAmB9C,MAAnB,GAA4B,CAA7B,IAAkCwF,OAAhD;AACD,KAND;;AAQApD,IAAAA,KAAK,CAAC+D,oBAAN,GAA6B,UAAUX,OAAV,EAAmB;AAC9C,UAAI5C,IAAI,GAAG,CAAX;;AACA,WAAK,IAAI9C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGsC,KAAK,CAAC8B,KAAN,CAAYpB,MAAZ,CAAmB9C,MAAvC,EAA+CF,CAAC,EAAhD,EAAoD;AAClD8C,QAAAA,IAAI,IAAIR,KAAK,CAAC2D,eAAN,CAAsBjG,CAAtB,EAAyBsC,KAAK,CAAC8B,KAAN,CAAYpB,MAArC,CAAR;AACD;;AACD,aAAOF,IAAI,GAAG,CAACR,KAAK,CAAC8B,KAAN,CAAYpB,MAAZ,CAAmB9C,MAAnB,GAA4B,CAA7B,IAAkCwF,OAAhD;AACD,KAND;;AAQApD,IAAAA,KAAK,CAACgE,YAAN,GAAqB,UAAUrB,UAAV,EAAsBnC,IAAtB,EAA4ByD,QAA5B,EAAsClB,IAAtC,EAA4C;AAC/D,UAAI,CAAC/C,KAAK,CAAC+C,IAAP,IAAeA,IAAnB,EAAyB;AACvB;AACA/C,QAAAA,KAAK,CAAC+C,IAAN,GAAaA,IAAb;AACD;;AACDvC,MAAAA,IAAI,GAAGR,KAAK,CAACI,KAAN,CAAY8B,SAAZ,KAA0B,QAA1B,GAAqC1B,IAAI,CAACiC,CAA1C,GAA8CjC,IAAI,CAACgC,CAA1D;;AACA,UAAIhC,IAAI,KAAKR,KAAK,CAAC8B,KAAN,CAAYpB,MAAZ,CAAmBiC,UAAnB,EAA+BnC,IAA5C,EAAkD;AAChD,YAAI6B,UAAU,GAAGrC,KAAK,CAAC8B,KAAN,CAAYpB,MAAZ,CAAmBwD,GAAnB,CAAuB,UAAUC,KAAV,EAAiB;AACvD,iBAAO7G,QAAQ,CAAC,EAAD,EAAK6G,KAAL,CAAf;AACD,SAFgB,CAAjB,CADgD,CAKhD;;;AACA,YAAI3D,IAAI,GAAG6B,UAAU,CAACM,UAAD,CAAV,CAAuBvB,OAAlC,EAA2C;AACzC,cAAIgD,IAAI,GAAG/B,UAAU,CAACM,UAAD,CAAV,CAAuBvB,OAAvB,GAAiCZ,IAA5C;AACA6B,UAAAA,UAAU,CAACM,UAAD,CAAV,CAAuBnC,IAAvB,GAA8B6B,UAAU,CAACM,UAAD,CAAV,CAAuBvB,OAArD,CAFyC,CAIzC;AACA;;AACA,eAAK,IAAI1D,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG2E,UAAU,CAACzE,MAA/B,EAAuCF,CAAC,IAAI,CAA5C,EAA+C;AAC7C,gBAAIA,CAAC,KAAKiF,UAAN,IAAoBN,UAAU,CAAC3E,CAAD,CAAV,CAAc4C,MAAd,KAAyB,SAAjD,EAA4D;AAC1D,kBAAI+D,SAAS,GAAGhC,UAAU,CAAC3E,CAAD,CAAV,CAAc8C,IAAd,GAAqB6B,UAAU,CAAC3E,CAAD,CAAV,CAAc0D,OAAnD;AACA,kBAAIkD,GAAG,GAAGjB,IAAI,CAACkB,GAAL,CAASH,IAAT,EAAeC,SAAf,CAAV;AACAhC,cAAAA,UAAU,CAAC3E,CAAD,CAAV,CAAc8C,IAAd,IAAsB8D,GAAtB,CAH0D,CAI1D;;AACAF,cAAAA,IAAI,IAAIE,GAAR;;AACA,kBAAIF,IAAI,KAAK,CAAb,EAAgB;AACd;AACD;AACF;AACF;AACF,SAlBD,MAkBO;AACL/B,UAAAA,UAAU,CAACM,UAAD,CAAV,CAAuBnC,IAAvB,GAA8BA,IAA9B;AACD;;AACDR,QAAAA,KAAK,CAAC0C,QAAN,CAAe;AAAEhC,UAAAA,MAAM,EAAE2B;AAAV,SAAf;;AACArC,QAAAA,KAAK,CAAC2B,QAAN,CAAeU,UAAf;;AAEA,YAAIM,UAAU,GAAG,CAAjB,EAAoB;AAClB3C,UAAAA,KAAK,CAACmC,YAAN,CAAmBQ,UAAU,GAAG,CAAhC,EAAmC;AAAEH,YAAAA,CAAC,EAAE,CAAL;AAAQC,YAAAA,CAAC,EAAE;AAAX,WAAnC;AACD,SAFD,MAEO,IAAIzC,KAAK,CAAC8B,KAAN,CAAYpB,MAAZ,CAAmB9C,MAAnB,GAA4B,CAAhC,EAAmC;AACxCoC,UAAAA,KAAK,CAACmC,YAAN,CAAmBQ,UAAU,GAAG,CAAhC,EAAmC;AAAEH,YAAAA,CAAC,EAAE,CAAL;AAAQC,YAAAA,CAAC,EAAE;AAAX,WAAnC;AACD;;AAED,YAAIwB,QAAJ,EAAc;AACZA,UAAAA,QAAQ;AACT;AACF;AACF,KA9CD;;AAgDAjE,IAAAA,KAAK,CAAC8B,KAAN,GAAc9B,KAAK,CAACS,UAAN,CAAiBT,KAAK,CAACI,KAAvB,CAAd;AACA,WAAOJ,KAAP;AACD,GAxS4D,CA0S7D;;;AAGAN,EAAAA,UAAU,CAAC3B,SAAX,CAAqByG,yBAArB,GAAiD,SAASA,yBAAT,CAAmCC,SAAnC,EAA8C;AAC7F,QAAIC,UAAU,GAAGD,SAAS,CAAClE,WAA3B,CAD6F,CAG7F;;AACA,QAAImE,UAAU,CAAC9G,MAAf,EAAuB;AACrB;AACA,UAAI,KAAKkE,KAAL,CAAWpB,MAAX,CAAkB9C,MAAlB,KAA6B8G,UAAU,CAAC9G,MAA5C,EAAoD;AAClD,aAAK8E,QAAL,CAAc,KAAKjC,UAAL,CAAgBgE,SAAhB,CAAd;AACD,OAFD,MAEO;AACL;AACA,aAAK,IAAI/G,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGgH,UAAU,CAAC9G,MAA/B,EAAuCF,CAAC,EAAxC,EAA4C;AAC1C,cAAI,KAAKoE,KAAL,CAAWpB,MAAX,CAAkBhD,CAAlB,EAAqB8C,IAArB,KAA8BkE,UAAU,CAAChH,CAAD,CAAV,CAAc8C,IAA5C,IAAoD,KAAKsB,KAAL,CAAWpB,MAAX,CAAkBhD,CAAlB,EAAqB0D,OAArB,KAAiCsD,UAAU,CAAChH,CAAD,CAAV,CAAc0D,OAAnG,IAA8G,KAAKU,KAAL,CAAWpB,MAAX,CAAkBhD,CAAlB,EAAqB2D,OAArB,KAAiCqD,UAAU,CAAChH,CAAD,CAAV,CAAc2D,OAA7J,IAAwK,KAAKS,KAAL,CAAWpB,MAAX,CAAkBhD,CAAlB,EAAqB4C,MAArB,KAAgCoE,UAAU,CAAChH,CAAD,CAAV,CAAc4C,MAA1N,EAAkO;AAChO,iBAAKoC,QAAL,CAAc,KAAKjC,UAAL,CAAgBgE,SAAhB,CAAd;AACA;AACD;AACF;AACF;AACF;AACF,GAlBD,CA7S6D,CAgU7D;AAGA;AACA;AAGA;;;AAGA/E,EAAAA,UAAU,CAAC3B,SAAX,CAAqB4G,QAArB,GAAgC,SAASA,QAAT,GAAoB;AAClD,QAAIC,UAAJ;;AAEA,QAAIC,SAAS,IAAID,UAAU,GAAG;AAC5BzB,MAAAA,KAAK,EAAE,MADqB;AAE5BD,MAAAA,MAAM,EAAE;AAFoB,KAAb,EAGd0B,UAAU,CAAC,QAAQ,KAAK5C,gBAAL,CAAsB,IAAtB,CAAT,CAAV,GAAkD,KAAK8B,oBAAL,CAA0B,KAAK1D,KAAL,CAAWgD,OAArC,CAHpC,EAGmFwB,UAAU,CAACE,OAAX,GAAqB,MAHxG,EAGgHF,UAAU,CAACG,aAAX,GAA2B,KAAK3E,KAAL,CAAW8B,SAHtJ,EAGiK0C,UAAU,CAACI,QAAX,GAAsB,CAHvL,EAG0LJ,UAH9L,CAAb;AAKA,WAAO;AACLC,MAAAA,SAAS,EAAEA,SADN;AAELV,MAAAA,KAAK,EAAE;AACLa,QAAAA,QAAQ,EAAE,CADL;AAELF,QAAAA,OAAO,EAAE;AAFJ;AAFF,KAAP;AAOD,GAfD;;AAiBApF,EAAAA,UAAU,CAAC3B,SAAX,CAAqBkH,aAArB,GAAqC,SAASA,aAAT,CAAuB5E,KAAvB,EAA8B;AACjE,QAAI6E,SAAJ;;AAEA,QAAIC,MAAM,GAAG,KAAK/E,KAAlB;AAAA,QACI8B,SAAS,GAAGiD,MAAM,CAACjD,SADvB;AAAA,QAEIkD,UAAU,GAAGD,MAAM,CAACC,UAFxB;AAKA,QAAIjB,KAAK,GAAG,KAAKrC,KAAL,CAAWpB,MAAX,CAAkBL,KAAlB,CAAZ;AACA,QAAIkB,KAAK,GAAG4C,KAAK,CAAC5C,KAAlB,CATiE,CAWjE;AACA;;AAEA,QAAI8D,aAAa,GAAG/H,QAAQ,EAAE4H,SAAS,GAAG,EAAZ,EAAgBA,SAAS,CAAC,KAAKlD,gBAAL,EAAD,CAAT,GAAqCmC,KAAK,CAAC3D,IAA3D,EAAiE0E,SAAS,CAAChD,SAAS,KAAK,KAAd,GAAsB,QAAtB,GAAiC,OAAlC,CAAT,GAAsD,MAAvH,EAA+HgD,SAAS,CAAC,QAAQ,KAAKlD,gBAAL,CAAsB,IAAtB,CAAT,CAAT,GAAiDmC,KAAK,CAAC7D,MAAN,KAAiB,SAAjB,GAA6B,CAA7B,GAAiC6D,KAAK,CAAC3D,IAAvN,EAA6N0E,SAAS,CAACF,QAAV,GAAqBb,KAAK,CAAC7D,MAAN,KAAiB,SAAjB,GAA6B,CAA7B,GAAiC,CAAnR,EAAsR4E,SAAS,CAACI,UAAV,GAAuBnB,KAAK,CAAC7D,MAAN,KAAiB,SAAjB,GAA6B,CAA7B,GAAiC,CAA9U,EAAiV4E,SAAS,CAACJ,OAAV,GAAoB,MAArW,EAA6WI,SAAS,CAACK,QAAV,GAAqB,QAAlY,EAA4YL,SAAS,CAACM,QAAV,GAAqB,UAAja,EAA6aN,SAA/a,GAA2b3D,KAA3b,CAA5B;;AACA,QAAI6D,UAAU,KAAK,IAAnB,EAAyB;AACvB;AACAC,MAAAA,aAAa,GAAG/H,QAAQ,CAAC,EAAD,EAAK+H,aAAL,EAAoB;AAC1CI,QAAAA,eAAe,EAAEL;AADyB,OAApB,CAAxB;AAGD;;AAED,WAAOC,aAAP;AACD,GAvBD;;AAyBA3F,EAAAA,UAAU,CAAC3B,SAAX,CAAqB2H,gBAArB,GAAwC,SAASA,gBAAT,CAA0BC,IAA1B,EAAgC;AACtE,QAAIC,UAAU,GAAGD,IAAI,CAACC,UAAtB;AAAA,QACIvF,KAAK,GAAGsF,IAAI,CAACtF,KADjB;AAAA,QAEIwF,eAAe,GAAGF,IAAI,CAACE,eAF3B;AAIA,QAAIC,UAAU,GAAG,KAAKhE,KAAL,CAAWpB,MAAX,CAAkBL,KAAlB,CAAjB;AACA,QAAIU,eAAe,GAAG,KAAtB,CANsE,CAOtE;;AACA,QAAIgF,QAAQ,GAAG;AACbC,MAAAA,OAAO,EAAE3F,KAAK,KAAK,CADN;AAEb4F,MAAAA,MAAM,EAAE5F,KAAK,KAAKwF,eAAe,CAACjI,MAAhB,GAAyB,CAF9B;AAGb0C,MAAAA,MAAM,EAAEwF,UAAU,CAACxF,MAHN;AAKb;AACA4F,MAAAA,cAAc,EAAEJ,UAAU,CAACxF,MAAX,KAAsB,SAAtB,GAAkC,KAAK0D,YAAvC,GAAsD;AANzD,KAAf,CARsE,CAiBtE;;AACA,QAAI8B,UAAU,CAACxF,MAAX,KAAsB,SAA1B,EAAqCS,eAAe,GAAG,IAAlB;AACrC,QAAI,CAACA,eAAD,IAAoBgF,QAAQ,CAACE,MAAjC,EAAyCF,QAAQ,CAACzF,MAAT,GAAkB,SAAlB;AAEzC,WAAOhD,QAAQ,CAAC;AACdiE,MAAAA,KAAK,EAAEqE,UADO;AAEd9H,MAAAA,GAAG,EAAEuC,KAFS;AAGd8F,MAAAA,OAAO,EAAE9F;AAHK,KAAD,EAIZ0F,QAJY,CAAf;AAKD,GA1BD;;AA4BArG,EAAAA,UAAU,CAAC3B,SAAX,CAAqBqI,WAArB,GAAmC,SAASA,WAAT,CAAqBC,KAArB,EAA4B;AAC7D,QAAIT,UAAU,GAAGS,KAAK,CAACT,UAAvB;AAAA,QACIvF,KAAK,GAAGgG,KAAK,CAAChG,KADlB;AAAA,QAEIwF,eAAe,GAAGQ,KAAK,CAACR,eAF5B;AAIA,QAAIS,KAAK,GAAG,KAAK9E,aAAL,EAAZ;AACA,WAAOlC,KAAK,CAACiH,aAAN,CACLD,KADK,EAEL,KAAKZ,gBAAL,CAAsB;AAAEE,MAAAA,UAAU,EAAEA,UAAd;AAA0BvF,MAAAA,KAAK,EAAEA,KAAjC;AAAwCwF,MAAAA,eAAe,EAAEA;AAAzD,KAAtB,CAFK,EAGLA,eAAe,CAACxF,KAAD,CAHV,CAAP;AAKD,GAXD,CAhZ6D,CA4Z7D;;;AAGAX,EAAAA,UAAU,CAAC3B,SAAX,CAAqByD,aAArB,GAAqC,SAASA,aAAT,GAAyB;AAC5D;AACA,WAAOhC,KAAP;AACD,GAHD;;AAKAE,EAAAA,UAAU,CAAC3B,SAAX,CAAqByI,WAArB,GAAmC,SAASA,WAAT,CAAqBC,KAArB,EAA4B;AAC7D,QAAIZ,eAAe,GAAGY,KAAK,CAACZ,eAA5B;AAAA,QACIa,WAAW,GAAGD,KAAK,CAACC,WADxB;AAAA,QAEIrG,KAAK,GAAGoG,KAAK,CAACpG,KAFlB,CAD6D,CAK7D;;AACA,QAAIA,KAAK,GAAGwF,eAAe,CAACjI,MAAhB,GAAyB,CAArC,EAAwC;AACtC8I,MAAAA,WAAW,CAAChF,IAAZ,CAAiBpC,KAAK,CAACiH,aAAN,CAAoB9G,OAApB,EAA6B;AAC5CkH,QAAAA,WAAW,EAAE,KAAKvG,KAAL,CAAWuG,WADoB;AAE5C7I,QAAAA,GAAG,EAAE,YAAYuC,KAF2B;AAG5C8F,QAAAA,OAAO,EAAE9F,KAHmC;AAI5C8B,QAAAA,YAAY,EAAE,KAAKA,YAJyB;AAK5CyE,QAAAA,YAAY,EAAE,KAAKxG,KAAL,CAAWgD,OALmB;AAM5ClB,QAAAA,SAAS,EAAE,KAAK9B,KAAL,CAAW8B,SANsB;AAO5C2E,QAAAA,WAAW,EAAE,KAAKzG,KAAL,CAAWyG,WAPoB;AAQ5ChF,QAAAA,aAAa,EAAE,KAAKA,aARwB;AAS5CE,QAAAA,WAAW,EAAE,KAAKA;AAT0B,OAA7B,CAAjB;AAWD;AACF,GAnBD,CApa6D,CAyb7D;AACA;AACA;AAGA;AACA;AAGA;AAGA;AAGA;AAGA;AAGA;AACA;;;AAGArC,EAAAA,UAAU,CAAC3B,SAAX,CAAqB+I,MAArB,GAA8B,SAASA,MAAT,GAAkB;AAC9C,QAAIC,MAAM,GAAG,IAAb;;AAEA,QAAIpG,QAAQ,GAAG,KAAKP,KAAL,CAAWO,QAA1B;AAGA,QAAIY,KAAK,GAAG,KAAKoD,QAAL,EAAZ,CAN8C,CAQ9C;;AACA,QAAIkB,eAAe,GAAGvG,KAAK,CAAC0B,QAAN,CAAeC,OAAf,CAAuBN,QAAvB,CAAtB;AACA,QAAI+F,WAAW,GAAG,EAAlB;;AAEA,SAAK,IAAIhJ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmI,eAAe,CAACjI,MAApC,EAA4CF,CAAC,EAA7C,EAAiD;AAC/C,UAAIkI,UAAU,GAAG,KAAKX,aAAL,CAAmBvH,CAAnB,CAAjB;AACA,UAAIsJ,QAAQ,GAAG,KAAKZ,WAAL,CAAiB;AAAER,QAAAA,UAAU,EAAEA,UAAd;AAA0BvF,QAAAA,KAAK,EAAE3C,CAAjC;AAAoCmI,QAAAA,eAAe,EAAEA;AAArD,OAAjB,CAAf;AACAa,MAAAA,WAAW,CAAChF,IAAZ,CAAiBsF,QAAjB;AACA,WAAKR,WAAL,CAAiB;AAAEX,QAAAA,eAAe,EAAEA,eAAnB;AAAoCa,QAAAA,WAAW,EAAEA,WAAjD;AAA8DrG,QAAAA,KAAK,EAAE3C;AAArE,OAAjB;AACD;;AAED,WAAO4B,KAAK,CAACiH,aAAN,CACL,KADK,EAEL;AACEU,MAAAA,SAAS,EAAE,YADb;AAEE1F,MAAAA,KAAK,EAAEA,KAAK,CAACsD,SAFf;AAGEqC,MAAAA,GAAG,EAAE,SAASA,GAAT,CAAanE,IAAb,EAAmB;AACtBgE,QAAAA,MAAM,CAAChE,IAAP,GAAcA,IAAd;AACD;AALH,KAFK,EASL2D,WATK,CAAP;AAWD,GA9BD;;AAgCA,SAAOhH,UAAP;AACD,CAnfkC,CAmfjCJ,KAAK,CAAC6H,SAnf2B,CAAjB,EAmfEjJ,MAAM,CAACuD,YAAP,GAAsB;AACxC2B,EAAAA,OAAO,EAAE,CAD+B;AAExClB,EAAAA,SAAS,EAAE,KAF6B;AAGxC3B,EAAAA,WAAW,EAAE,EAH2B;AAIxCoB,EAAAA,QAAQ,EAAER,SAJ8B;AAKxCU,EAAAA,aAAa,EAAEV,SALyB;AAMxCY,EAAAA,WAAW,EAAEZ,SAN2B;AAOxCiE,EAAAA,UAAU,EAAEjE,SAP4B;AAQxCwF,EAAAA,WAAW,EAAExF,SAR2B;AASxC0F,EAAAA,WAAW,EAAE;AAT2B,CAnfxB,EA6ff1I,KA7fW,CAAd;AA8fA,SAASuB,UAAU,IAAI0H,OAAvB;AACA1H,UAAU,CAAC2H,SAAX,GAAuBC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwC;AAC7DpE,EAAAA,OAAO,EAAE7D,SAAS,CAACkI,MAD0C;AAE7DvF,EAAAA,SAAS,EAAE3C,SAAS,CAACmI,MAFwC;AAG7DnH,EAAAA,WAAW,EAAEhB,SAAS,CAACoI,KAHsC;AAI7DhH,EAAAA,QAAQ,EAAEpB,SAAS,CAACqI,SAAV,CAAoB,CAACrI,SAAS,CAACoI,KAAX,EAAkBpI,SAAS,CAACsI,MAA5B,CAApB,EAAyDC,UAJN;AAK7DnG,EAAAA,QAAQ,EAAEpC,SAAS,CAACwI,IALyC;AAM7DlG,EAAAA,aAAa,EAAEtC,SAAS,CAACwI,IANoC;AAO7DhG,EAAAA,WAAW,EAAExC,SAAS,CAACwI,IAPsC;AAQ7D3C,EAAAA,UAAU,EAAE7F,SAAS,CAACmI,MARuC;AAS7Df,EAAAA,WAAW,EAAEpH,SAAS,CAACmI,MATsC;AAU7Db,EAAAA,WAAW,EAAEtH,SAAS,CAACyI;AAVsC,CAAxC,GAWnB,EAXJ","sourcesContent":["var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _class, _temp;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\n\nimport Panel from './Panel';\nimport Divider from './Divider';\n\nexport { Divider, Panel };\n\nvar PanelGroup = (_temp = _class = function (_React$Component) {\n  _inherits(PanelGroup, _React$Component);\n\n  // Load initial panel configuration from props\n  function PanelGroup() {\n    _classCallCheck(this, PanelGroup);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var _this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args)));\n\n    _this.defaultResize = function (props, index, defaultResize) {\n      var resize = defaultResize;\n      if (props.panelWidths[index].resize) {\n        resize = props.panelWidths[index].resize; // eslint-disable-line\n      } else {\n        resize = props.panelWidths[index].size ? 'dynamic' : resize;\n      }\n      return resize;\n    };\n\n    _this.loadPanels = function (props) {\n      var panels = [];\n\n      if (props.children) {\n        // Default values if none were provided\n        var defaultSize = 256;\n        var defaultMinSize = 48;\n        var defaultMaxSize = 0;\n        var defaultResize = 'stretch';\n\n        var stretchIncluded = false;\n        var children = React.Children.toArray(props.children);\n\n        for (var i = 0; i < children.length; i++) {\n          if (i < props.panelWidths.length && props.panelWidths[i]) {\n            var widthObj = {\n              size: props.panelWidths[i].size !== undefined ? props.panelWidths[i].size : defaultSize,\n              minSize: props.panelWidths[i].minSize !== undefined ? props.panelWidths[i].minSize : defaultMinSize,\n              maxSize: props.panelWidths[i].maxSize !== undefined ? props.panelWidths[i].maxSize : defaultMaxSize,\n              resize: _this.defaultResize(props, i, defaultResize),\n              snap: props.panelWidths[i].snap !== undefined ? props.panelWidths[i].snap : [],\n              style: _extends({}, _this.getPanelClass().defaultProps.style, props.panelWidths[i].style || {})\n            };\n            panels.push(widthObj);\n          } else {\n            // default values if no props are given\n            panels.push({\n              size: defaultSize,\n              resize: defaultResize,\n              minSize: defaultMinSize,\n              maxSize: defaultMaxSize,\n              snap: [],\n              style: {}\n            });\n          }\n\n          // if none of the panels included was stretchy, make the last one stretchy\n          if (panels[i].resize === 'stretch') stretchIncluded = true;\n          if (!stretchIncluded && i === children.length - 1) panels[i].resize = 'stretch';\n        }\n      }\n\n      return {\n        panels: panels\n      };\n    };\n\n    _this.onUpdate = function (panels) {\n      if (_this.props.onUpdate) {\n        _this.props.onUpdate(panels.slice());\n      }\n    };\n\n    _this.onResizeStart = function () {\n      if (_this.props.onResizeStart) {\n        // actually this slice clones only array, underlying objects stays the same\n        _this.props.onResizeStart(_this.state.panels.slice());\n      }\n    };\n\n    _this.onResizeEnd = function () {\n      if (_this.props.onResizeEnd) {\n        _this.props.onResizeEnd(_this.state.panels.slice());\n      }\n    };\n\n    _this.getSizeDirection = function (caps) {\n      if (caps) {\n        return _this.props.direction === 'column' ? 'Height' : 'Width';\n      }\n      return _this.props.direction === 'column' ? 'height' : 'width';\n    };\n\n    _this.handleResize = function (i, delta) {\n      var tempPanels = _this.state.panels.slice();\n      var returnDelta = _this.resizePanel(i, _this.props.direction === 'row' ? delta.x : delta.y, tempPanels);\n      _this.setState({ panels: tempPanels });\n      _this.onUpdate(tempPanels);\n      return returnDelta;\n    };\n\n    _this.resizePanel = function (panelIndex, delta, panels) {\n      // 1) first let's calculate and make sure all the sizes add up to be correct.\n      var masterSize = 0;\n      for (var iti = 0; iti < panels.length; iti += 1) {\n        masterSize += panels[iti].size;\n      }\n      var boundingRect = _this.node.getBoundingClientRect();\n      var boundingSize = (_this.props.direction === 'column' ? boundingRect.height : boundingRect.width) - _this.props.spacing * (_this.props.children.length - 1);\n      if (Math.abs(boundingSize - masterSize) <= 0.01) {\n        // Debug log\n        // console.log({ panels }, `ERROR! SIZES DON'T MATCH!: ${masterSize}, ${boundingSize}`)\n\n        // 2) Rectify the situation by adding all the unacounted for space to the first panel\n        panels[panelIndex].size += boundingSize - masterSize;\n      }\n\n      var minsize = void 0;\n      var maxsize = void 0;\n\n      // track the progressive delta so we can report back how much this panel\n      // actually moved after all the adjustments have been made\n      var resultDelta = delta;\n\n      // make the changes and deal with the consequences later\n      panels[panelIndex].size += delta;\n      panels[panelIndex + 1].size -= delta;\n\n      // Min and max for LEFT panel\n      minsize = _this.getPanelMinSize(panelIndex, panels);\n      maxsize = _this.getPanelMaxSize(panelIndex, panels);\n\n      // if we made the left panel too small\n      if (panels[panelIndex].size < minsize) {\n        delta = minsize - panels[panelIndex].size;\n\n        if (panelIndex === 0) {\n          resultDelta = _this.resizePanel(panelIndex, delta, panels);\n        } else {\n          resultDelta = _this.resizePanel(panelIndex - 1, -delta, panels);\n        }\n      }\n\n      // if we made the left panel too big\n      if (maxsize !== 0 && panels[panelIndex].size > maxsize) {\n        delta = panels[panelIndex].size - maxsize;\n\n        if (panelIndex === 0) {\n          resultDelta = _this.resizePanel(panelIndex, -delta, panels);\n        } else {\n          resultDelta = _this.resizePanel(panelIndex - 1, delta, panels);\n        }\n      }\n\n      // Min and max for RIGHT panel\n      minsize = _this.getPanelMinSize(panelIndex + 1, panels);\n      maxsize = _this.getPanelMaxSize(panelIndex + 1, panels);\n\n      // if we made the right panel too small\n      if (panels[panelIndex + 1].size < minsize) {\n        delta = minsize - panels[panelIndex + 1].size;\n\n        if (panelIndex + 1 === panels.length - 1) {\n          resultDelta = _this.resizePanel(panelIndex, -delta, panels);\n        } else {\n          resultDelta = _this.resizePanel(panelIndex + 1, delta, panels);\n        }\n      }\n\n      // if we made the right panel too big\n      if (maxsize !== 0 && panels[panelIndex + 1].size > maxsize) {\n        delta = panels[panelIndex + 1].size - maxsize;\n\n        if (panelIndex + 1 === panels.length - 1) {\n          resultDelta = _this.resizePanel(panelIndex, delta, panels);\n        } else {\n          resultDelta = _this.resizePanel(panelIndex + 1, -delta, panels);\n        }\n      }\n\n      // Iterate through left panel's snap positions\n      for (var i = 0; i < panels[panelIndex].snap.length; i++) {\n        if (Math.abs(panels[panelIndex].snap[i] - panels[panelIndex].size) < 20) {\n          delta = panels[panelIndex].snap[i] - panels[panelIndex].size;\n\n          if (delta !== 0 && panels[panelIndex].size + delta >= _this.getPanelMinSize(panelIndex, panels) && panels[panelIndex + 1].size - delta >= _this.getPanelMinSize(panelIndex + 1, panels)) {\n            resultDelta = _this.resizePanel(panelIndex, delta, panels);\n          }\n        }\n      }\n\n      // Iterate through right panel's snap positions\n      for (var _i = 0; _i < panels[panelIndex + 1].snap.length; _i++) {\n        if (Math.abs(panels[panelIndex + 1].snap[_i] - panels[panelIndex + 1].size) < 20) {\n          delta = panels[panelIndex + 1].snap[_i] - panels[panelIndex + 1].size;\n\n          if (delta !== 0 && panels[panelIndex].size + delta >= _this.getPanelMinSize(panelIndex, panels) && panels[panelIndex + 1].size - delta >= _this.getPanelMinSize(panelIndex + 1, panels)) {\n            resultDelta = _this.resizePanel(panelIndex, -delta, panels);\n          }\n        }\n      }\n\n      // return how much this panel actually resized\n      return resultDelta;\n    };\n\n    _this.getPanelMinSize = function (panelIndex, panels) {\n      if (panels[panelIndex].resize === 'fixed') {\n        if (!panels[panelIndex].fixedSize) {\n          panels[panelIndex].fixedSize = panels[panelIndex].size;\n        }\n        return panels[panelIndex].fixedSize;\n      }\n      return panels[panelIndex].minSize;\n    };\n\n    _this.getPanelMaxSize = function (panelIndex, panels) {\n      if (panels[panelIndex].resize === 'fixed') {\n        if (!panels[panelIndex].fixedSize) {\n          panels[panelIndex].fixedSize = panels[panelIndex].size;\n        }\n        return panels[panelIndex].fixedSize;\n      }\n      return panels[panelIndex].maxSize;\n      // return 0;\n    };\n\n    _this.getPanelGroupMinSize = function (spacing) {\n      var size = 0;\n      for (var i = 0; i < _this.state.panels.length; i++) {\n        size += _this.getPanelMinSize(i, _this.state.panels);\n      }\n      return size + (_this.state.panels.length - 1) * spacing;\n    };\n\n    _this.getPanelGroupMaxSize = function (spacing) {\n      var size = 0;\n      for (var i = 0; i < _this.state.panels.length; i++) {\n        size += _this.getPanelMaxSize(i, _this.state.panels);\n      }\n      return size + (_this.state.panels.length - 1) * spacing;\n    };\n\n    _this.setPanelSize = function (panelIndex, size, callback, node) {\n      if (!_this.node && node) {\n        // due to timing child elements may have parent node first!\n        _this.node = node;\n      }\n      size = _this.props.direction === 'column' ? size.y : size.x;\n      if (size !== _this.state.panels[panelIndex].size) {\n        var tempPanels = _this.state.panels.map(function (panel) {\n          return _extends({}, panel);\n        });\n\n        // make sure we can actually resize this panel this small\n        if (size < tempPanels[panelIndex].minSize) {\n          var diff = tempPanels[panelIndex].minSize - size;\n          tempPanels[panelIndex].size = tempPanels[panelIndex].minSize;\n\n          // 1) Find all of the dynamic panels that we can resize and\n          // decrease them until the difference is gone\n          for (var i = 0; i < tempPanels.length; i += 1) {\n            if (i !== panelIndex && tempPanels[i].resize === 'dynamic') {\n              var available = tempPanels[i].size - tempPanels[i].minSize;\n              var cut = Math.min(diff, available);\n              tempPanels[i].size -= cut;\n              // if the difference is gone then we are done!\n              diff -= cut;\n              if (diff === 0) {\n                break;\n              }\n            }\n          }\n        } else {\n          tempPanels[panelIndex].size = size;\n        }\n        _this.setState({ panels: tempPanels });\n        _this.onUpdate(tempPanels);\n\n        if (panelIndex > 0) {\n          _this.handleResize(panelIndex - 1, { x: 0, y: 0 });\n        } else if (_this.state.panels.length > 2) {\n          _this.handleResize(panelIndex + 1, { x: 0, y: 0 });\n        }\n\n        if (callback) {\n          callback();\n        }\n      }\n    };\n\n    _this.state = _this.loadPanels(_this.props);\n    return _this;\n  }\n\n  // reload panel configuration if props update\n\n\n  PanelGroup.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    var nextPanels = nextProps.panelWidths;\n\n    // Only update from props if we're supplying the props in the first place\n    if (nextPanels.length) {\n      // if the panel array is a different size we know to update\n      if (this.state.panels.length !== nextPanels.length) {\n        this.setState(this.loadPanels(nextProps));\n      } else {\n        // otherwise we need to iterate to spot any difference\n        for (var i = 0; i < nextPanels.length; i++) {\n          if (this.state.panels[i].size !== nextPanels[i].size || this.state.panels[i].minSize !== nextPanels[i].minSize || this.state.panels[i].maxSize !== nextPanels[i].maxSize || this.state.panels[i].resize !== nextPanels[i].resize) {\n            this.setState(this.loadPanels(nextProps));\n            break;\n          }\n        }\n      }\n    }\n  };\n  // load provided props into state\n\n\n  // Pass internal state out if there's a callback for it\n  // Useful for saving panel configuration\n\n\n  // For styling, track which direction to apply sizing to\n\n\n  PanelGroup.prototype.getStyle = function getStyle() {\n    var _container;\n\n    var container = (_container = {\n      width: '100%',\n      height: '100%'\n    }, _container['min' + this.getSizeDirection(true)] = this.getPanelGroupMinSize(this.props.spacing), _container.display = 'flex', _container.flexDirection = this.props.direction, _container.flexGrow = 1, _container);\n\n    return {\n      container: container,\n      panel: {\n        flexGrow: 0,\n        display: 'flex'\n      }\n    };\n  };\n\n  PanelGroup.prototype.getPanelStyle = function getPanelStyle(index) {\n    var _extends2;\n\n    var _props = this.props,\n        direction = _props.direction,\n        panelColor = _props.panelColor;\n\n\n    var panel = this.state.panels[index];\n    var style = panel.style;\n\n    // setting up the style for this panel.  Should probably be handled\n    // in the child component, but this was easier for now\n\n    var newPanelStyle = _extends((_extends2 = {}, _extends2[this.getSizeDirection()] = panel.size, _extends2[direction === 'row' ? 'height' : 'width'] = '100%', _extends2['min' + this.getSizeDirection(true)] = panel.resize === 'stretch' ? 0 : panel.size, _extends2.flexGrow = panel.resize === 'stretch' ? 1 : 0, _extends2.flexShrink = panel.resize === 'stretch' ? 1 : 0, _extends2.display = 'flex', _extends2.overflow = 'hidden', _extends2.position = 'relative', _extends2), style);\n    if (panelColor !== null) {\n      // patch in the background color if it was supplied as a prop\n      newPanelStyle = _extends({}, newPanelStyle, {\n        backgroundColor: panelColor\n      });\n    }\n\n    return newPanelStyle;\n  };\n\n  PanelGroup.prototype.createPanelProps = function createPanelProps(_ref) {\n    var panelStyle = _ref.panelStyle,\n        index = _ref.index,\n        initialChildren = _ref.initialChildren;\n\n    var panelState = this.state.panels[index];\n    var stretchIncluded = false;\n    // give position info to children\n    var metadata = {\n      isFirst: index === 0,\n      isLast: index === initialChildren.length - 1,\n      resize: panelState.resize,\n\n      // window resize handler if this panel is stretchy\n      onWindowResize: panelState.resize === 'stretch' ? this.setPanelSize : null\n    };\n\n    // if none of the panels included was stretchy, make the last one stretchy\n    if (panelState.resize === 'stretch') stretchIncluded = true;\n    if (!stretchIncluded && metadata.isLast) metadata.resize = 'stretch';\n\n    return _extends({\n      style: panelStyle,\n      key: index,\n      panelID: index\n    }, metadata);\n  };\n\n  PanelGroup.prototype.createPanel = function createPanel(_ref2) {\n    var panelStyle = _ref2.panelStyle,\n        index = _ref2.index,\n        initialChildren = _ref2.initialChildren;\n\n    var Klass = this.getPanelClass();\n    return React.createElement(\n      Klass,\n      this.createPanelProps({ panelStyle: panelStyle, index: index, initialChildren: initialChildren }),\n      initialChildren[index]\n    );\n  };\n  // eslint-disable-next-line class-methods-use-this\n\n\n  PanelGroup.prototype.getPanelClass = function getPanelClass() {\n    // mainly for accessing default props of panels\n    return Panel;\n  };\n\n  PanelGroup.prototype.maybeDivide = function maybeDivide(_ref3) {\n    var initialChildren = _ref3.initialChildren,\n        newChildren = _ref3.newChildren,\n        index = _ref3.index;\n\n    // add a handle between panels\n    if (index < initialChildren.length - 1) {\n      newChildren.push(React.createElement(Divider, {\n        borderColor: this.props.borderColor,\n        key: 'divider' + index,\n        panelID: index,\n        handleResize: this.handleResize,\n        dividerWidth: this.props.spacing,\n        direction: this.props.direction,\n        showHandles: this.props.showHandles,\n        onResizeStart: this.onResizeStart,\n        onResizeEnd: this.onResizeEnd\n      }));\n    }\n  };\n\n  // Entry point for resizing panels.\n  // We clone the panel array and perform operations on it so we can\n  // setState after the recursive operations are finished\n\n\n  // Recursive panel resizing so we can push other panels out of the way\n  // if we've exceeded the target panel's extents\n\n\n  // Utility function for getting min pixel size of panel\n\n\n  // Utility function for getting max pixel size of panel\n\n\n  // Utility function for getting min pixel size of the entire panel group\n\n\n  // Utility function for getting max pixel size of the entire panel group\n\n\n  // Hard-set a panel's size\n  // Used to recalculate a stretchy panel when the window is resized\n\n\n  PanelGroup.prototype.render = function render() {\n    var _this2 = this;\n\n    var children = this.props.children;\n\n\n    var style = this.getStyle();\n\n    // lets build up a new children array with added resize borders\n    var initialChildren = React.Children.toArray(children);\n    var newChildren = [];\n\n    for (var i = 0; i < initialChildren.length; i++) {\n      var panelStyle = this.getPanelStyle(i);\n      var newPanel = this.createPanel({ panelStyle: panelStyle, index: i, initialChildren: initialChildren });\n      newChildren.push(newPanel);\n      this.maybeDivide({ initialChildren: initialChildren, newChildren: newChildren, index: i });\n    }\n\n    return React.createElement(\n      'div',\n      {\n        className: 'panelGroup',\n        style: style.container,\n        ref: function ref(node) {\n          _this2.node = node;\n        }\n      },\n      newChildren\n    );\n  };\n\n  return PanelGroup;\n}(React.Component), _class.defaultProps = {\n  spacing: 1,\n  direction: 'row',\n  panelWidths: [],\n  onUpdate: undefined,\n  onResizeStart: undefined,\n  onResizeEnd: undefined,\n  panelColor: undefined,\n  borderColor: undefined,\n  showHandles: false\n}, _temp);\nexport { PanelGroup as default };\nPanelGroup.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  spacing: PropTypes.number,\n  direction: PropTypes.string,\n  panelWidths: PropTypes.array,\n  children: PropTypes.oneOfType([PropTypes.array, PropTypes.object]).isRequired,\n  onUpdate: PropTypes.func,\n  onResizeStart: PropTypes.func,\n  onResizeEnd: PropTypes.func,\n  panelColor: PropTypes.string,\n  borderColor: PropTypes.string,\n  showHandles: PropTypes.bool\n} : {};"]},"metadata":{},"sourceType":"module"}